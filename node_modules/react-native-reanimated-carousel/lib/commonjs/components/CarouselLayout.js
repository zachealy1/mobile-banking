"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CarouselLayout = void 0;

var _react = _interopRequireDefault(require("react"));

var _reactNative = require("react-native");

var _reactNativeGestureHandler = require("react-native-gesture-handler");

var _reactNativeReanimated = require("react-native-reanimated");

var _useAutoPlay = require("../hooks/useAutoPlay");

var _useCarouselController = require("../hooks/useCarouselController");

var _useCommonVariables = require("../hooks/useCommonVariables");

var _useLayoutConfig = require("../hooks/useLayoutConfig");

var _useOnProgressChange = require("../hooks/useOnProgressChange");

var _store = require("../store");

var _computedWithAutoFillData = require("../utils/computed-with-auto-fill-data");

var _ItemRenderer = require("./ItemRenderer");

var _ScrollViewGesture = require("./ScrollViewGesture");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const CarouselLayout = /*#__PURE__*/_react.default.forwardRef((_props, ref) => {
  const {
    props,
    layout
  } = (0, _store.useGlobalState)();
  const {
    itemDimensions
  } = layout;
  const {
    testID,
    loop,
    autoFillData,
    // Fill data with autoFillData
    data,
    // Length of fill data
    dataLength,
    // Length of raw data
    rawDataLength,
    mode,
    style,
    containerStyle,
    width,
    height,
    vertical,
    autoPlay,
    windowSize,
    autoPlayReverse,
    autoPlayInterval,
    scrollAnimationDuration,
    withAnimation,
    fixedDirection,
    renderItem,
    onScrollEnd,
    onSnapToItem,
    onScrollStart,
    onProgressChange,
    customAnimation,
    defaultIndex
  } = props;
  const commonVariables = (0, _useCommonVariables.useCommonVariables)(props);
  const {
    size,
    handlerOffset
  } = commonVariables;
  const layoutConfig = (0, _useLayoutConfig.useLayoutConfig)({ ...props,
    size
  });
  const offsetX = (0, _reactNativeReanimated.useDerivedValue)(() => {
    const totalSize = size * dataLength;
    const x = handlerOffset.value % totalSize;
    if (!loop) return handlerOffset.value;
    return Number.isNaN(x) ? 0 : x;
  }, [loop, size, dataLength]);
  (0, _useOnProgressChange.useOnProgressChange)({
    autoFillData,
    loop,
    size,
    offsetX,
    rawDataLength,
    onProgressChange
  });
  const carouselController = (0, _useCarouselController.useCarouselController)({
    ref,
    loop,
    size,
    dataLength,
    autoFillData,
    handlerOffset,
    withAnimation,
    defaultIndex,
    fixedDirection,
    duration: scrollAnimationDuration,
    onScrollEnd: () => (0, _reactNativeReanimated.runOnJS)(_onScrollEnd)(),
    onScrollStart: () => !!onScrollStart && (0, _reactNativeReanimated.runOnJS)(onScrollStart)()
  });
  const {
    getSharedIndex // index, // Animated index. Could be used for dynamic dimension

  } = carouselController;

  const _onScrollEnd = _react.default.useCallback(() => {
    const _sharedIndex = Math.round(getSharedIndex());

    const realIndex = (0, _computedWithAutoFillData.computedRealIndexWithAutoFillData)({
      index: _sharedIndex,
      dataLength: rawDataLength,
      loop,
      autoFillData
    });
    if (onSnapToItem) onSnapToItem(realIndex);
    if (onScrollEnd) onScrollEnd(realIndex);
  }, [loop, autoFillData, rawDataLength, getSharedIndex, onSnapToItem, onScrollEnd]);

  const {
    start: startAutoPlay,
    pause: pauseAutoPlay
  } = (0, _useAutoPlay.useAutoPlay)({
    autoPlay,
    autoPlayInterval,
    autoPlayReverse,
    carouselController
  });

  const scrollViewGestureOnScrollStart = _react.default.useCallback(() => {
    pauseAutoPlay();
    onScrollStart === null || onScrollStart === void 0 ? void 0 : onScrollStart();
  }, [onScrollStart, pauseAutoPlay]);

  const scrollViewGestureOnScrollEnd = _react.default.useCallback(() => {
    startAutoPlay();

    _onScrollEnd();
  }, [_onScrollEnd, startAutoPlay]);

  const scrollViewGestureOnTouchBegin = _react.default.useCallback(pauseAutoPlay, [pauseAutoPlay]);

  const scrollViewGestureOnTouchEnd = _react.default.useCallback(startAutoPlay, [startAutoPlay]);

  const layoutStyle = (0, _reactNativeReanimated.useAnimatedStyle)(() => {
    // const dimension = itemDimensions.value[index.value];
    // if (!dimension) {
    //   return {};
    // }
    return {
      // height: dimension.height, // For dynamic dimension in the future
      width: width || "100%",
      // [width is deprecated]
      height: height || "100%" // [height is deprecated]

    };
  }, [width, height, size, itemDimensions]);
  return /*#__PURE__*/_react.default.createElement(_reactNativeGestureHandler.GestureHandlerRootView, {
    style: [styles.layoutContainer, containerStyle]
  }, /*#__PURE__*/_react.default.createElement(_ScrollViewGesture.ScrollViewGesture, {
    size: size,
    key: mode,
    translation: handlerOffset,
    style: [styles.contentContainer, // [deprecated]
    layoutStyle, style, vertical ? styles.itemsVertical : styles.itemsHorizontal],
    testID: testID,
    onScrollStart: scrollViewGestureOnScrollStart,
    onScrollEnd: scrollViewGestureOnScrollEnd,
    onTouchBegin: scrollViewGestureOnTouchBegin,
    onTouchEnd: scrollViewGestureOnTouchEnd
  }, /*#__PURE__*/_react.default.createElement(_ItemRenderer.ItemRenderer, {
    data: data,
    dataLength: dataLength,
    rawDataLength: rawDataLength,
    loop: loop,
    size: size,
    windowSize: windowSize,
    autoFillData: autoFillData,
    offsetX: offsetX,
    handlerOffset: handlerOffset,
    layoutConfig: layoutConfig,
    renderItem: renderItem,
    customAnimation: customAnimation
  })));
});

exports.CarouselLayout = CarouselLayout;

const styles = _reactNative.StyleSheet.create({
  layoutContainer: {
    display: "flex"
  },
  contentContainer: {
    overflow: "hidden"
  },
  itemsHorizontal: {
    flexDirection: "row"
  },
  itemsVertical: {
    flexDirection: "column"
  }
});
//# sourceMappingURL=CarouselLayout.js.map