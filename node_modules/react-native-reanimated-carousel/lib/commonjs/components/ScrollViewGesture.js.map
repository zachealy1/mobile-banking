{"version":3,"sources":["ScrollViewGesture.tsx"],"names":["IScrollViewGesture","props","onConfigurePanGesture","vertical","pagingEnabled","snapEnabled","loop","scrollAnimationDuration","withAnimation","enabled","dataLength","overscrollEnabled","maxScrollDistancePerSwipe","minScrollDistancePerSwipe","fixedDirection","common","size","layout","updateContainerSize","translation","testID","style","onScrollStart","onScrollEnd","onTouchBegin","onTouchEnd","maxPage","isHorizontal","max","panOffset","undefined","touching","validStart","scrollEndTranslation","scrollEndVelocity","containerRef","maxScrollDistancePerSwipeIsSet","minScrollDistancePerSwipeIsSet","getLimit","React","useCallback","measurement","containerWidth","width","withSpring","toValue","onFinished","defaultWithAnimation","type","config","duration","easing","Easing","easeOutQuart","isFinished","endWithSpring","scrollEndTranslationValue","scrollEndVelocityValue","origin","value","velocity","finalTranslation","deceleration","Math","abs","nextPage","round","offset","computed","ceil","floor","page","velocityDirection","sign","withProcessTranslation","finalPage","min","limit","onFinish","activeDecay","resetBoundary","onGestureStart","_","onGestureUpdate","e","translationX","translationY","panTranslation","boundary","fixed","dynamic","translationValue","onGestureEnd","_success","velocityX","velocityY","totalTranslation","gesture","options","onLayout","nativeEvent","height","children","ScrollViewGesture"],"mappings":"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","sourcesContent":["import type { PropsWithChildren } from \"react\";\nimport React, { useCallback } from \"react\";\nimport type { LayoutChangeEvent, StyleProp, ViewStyle } from \"react-native\";\nimport type {\n  GestureStateChangeEvent,\n  PanGestureHandlerEventPayload,\n} from \"react-native-gesture-handler\";\nimport { GestureDetector } from \"react-native-gesture-handler\";\nimport Animated, {\n  cancelAnimation,\n  measure,\n  runOnJS,\n  useAnimatedReaction,\n  useAnimatedRef,\n  useDerivedValue,\n  useSharedValue,\n  withDecay,\n} from \"react-native-reanimated\";\n\nimport { Easing } from \"../constants\";\nimport { usePanGestureProxy } from \"../hooks/usePanGestureProxy\";\nimport { useGlobalState } from \"../store\";\nimport type { WithTimingAnimation } from \"../types\";\nimport { dealWithAnimation } from \"../utils/deal-with-animation\";\n\ninterface Props {\n  size: number;\n  infinite?: boolean;\n  testID?: string;\n  style?: StyleProp<ViewStyle>;\n  translation: Animated.SharedValue<number>;\n  onLayout?: (e: LayoutChangeEvent) => void;\n  onScrollStart?: () => void;\n  onScrollEnd?: () => void;\n  onTouchBegin?: () => void;\n  onTouchEnd?: () => void;\n}\n\nconst IScrollViewGesture: React.FC<PropsWithChildren<Props>> = (props) => {\n  const {\n    props: {\n      onConfigurePanGesture,\n      vertical,\n      pagingEnabled,\n      snapEnabled,\n      loop,\n      scrollAnimationDuration,\n      withAnimation,\n      enabled,\n      dataLength,\n      overscrollEnabled,\n      maxScrollDistancePerSwipe,\n      minScrollDistancePerSwipe,\n      fixedDirection,\n    },\n    common: { size },\n    layout: { updateContainerSize },\n  } = useGlobalState();\n\n  const {\n    translation,\n    testID,\n    style = {},\n    onScrollStart,\n    onScrollEnd,\n    onTouchBegin,\n    onTouchEnd,\n  } = props;\n\n  const maxPage = dataLength;\n  const isHorizontal = useDerivedValue(() => !vertical, [vertical]);\n  const max = useSharedValue(0);\n  const panOffset = useSharedValue<number | undefined>(undefined); // set to undefined when not actively in a pan gesture\n  const touching = useSharedValue(false);\n  const validStart = useSharedValue(false);\n  const scrollEndTranslation = useSharedValue(0);\n  const scrollEndVelocity = useSharedValue(0);\n  const containerRef = useAnimatedRef<Animated.View>();\n  const maxScrollDistancePerSwipeIsSet = typeof maxScrollDistancePerSwipe === \"number\";\n  const minScrollDistancePerSwipeIsSet = typeof minScrollDistancePerSwipe === \"number\";\n\n  // Get the limit of the scroll.\n  const getLimit = React.useCallback(() => {\n    \"worklet\";\n\n    if (!loop && !overscrollEnabled) {\n      const measurement = measure(containerRef);\n      const containerWidth = measurement?.width || 0;\n\n      // If the item's total width is less than the container's width, then there is no need to scroll.\n      if (dataLength * size < containerWidth) return 0;\n\n      // Disable the \"overscroll\" effect\n      return dataLength * size - containerWidth;\n    }\n\n    return dataLength * size;\n  }, [loop, size, dataLength, overscrollEnabled]);\n\n  const withSpring = React.useCallback(\n    (toValue: number, onFinished?: () => void) => {\n      \"worklet\";\n      const defaultWithAnimation: WithTimingAnimation = {\n        type: \"timing\",\n        config: {\n          duration: scrollAnimationDuration + 100,\n          easing: Easing.easeOutQuart,\n        },\n      };\n\n      return dealWithAnimation(withAnimation ?? defaultWithAnimation)(\n        toValue,\n        (isFinished: boolean) => {\n          \"worklet\";\n          if (isFinished) onFinished && runOnJS(onFinished)();\n        }\n      );\n    },\n    [scrollAnimationDuration, withAnimation]\n  );\n\n  const endWithSpring = React.useCallback(\n    (\n      scrollEndTranslationValue: number,\n      scrollEndVelocityValue: number,\n      onFinished?: () => void\n    ) => {\n      \"worklet\";\n      const origin = translation.value;\n      const velocity = scrollEndVelocityValue;\n      // Default to scroll in the direction of the slide (with deceleration)\n      let finalTranslation: number = withDecay({ velocity, deceleration: 0.999 });\n\n      // If the distance of the swipe exceeds the max scroll distance, keep the view at the current position\n      if (\n        maxScrollDistancePerSwipeIsSet &&\n        Math.abs(scrollEndTranslationValue) > maxScrollDistancePerSwipe\n      ) {\n        finalTranslation = origin;\n      } else {\n        /**\n         * The page size is the same as the item size.\n         * If direction is vertical, the page size is the height of the item.\n         * If direction is horizontal, the page size is the width of the item.\n         *\n         * `page size` equals to `size` variable.\n         * */\n\n        // calculate target \"nextPage\" based on the final pan position and the velocity of\n        // the pan gesture at termination; this allows for a quick \"flick\" to indicate a far\n        // off page change.\n        const nextPage = -Math.round((origin + velocity * 2) / size);\n\n        if (pagingEnabled) {\n          // we'll never go further than a single page away from the current page when paging\n          // is enabled.\n\n          // distance with direction\n          const offset = -(scrollEndTranslationValue >= 0 ? 1 : -1); // 1 or -1\n          const computed = offset < 0 ? Math.ceil : Math.floor;\n          const page = computed(-origin / size);\n\n          const velocityDirection = -Math.sign(velocity);\n          if (page === nextPage || velocityDirection !== offset) {\n            // not going anywhere! Velocity was insufficient to overcome the distance to get to a\n            // further page. Let's reset gently to the current page.\n            finalTranslation = withSpring(withProcessTranslation(-page * size), onFinished);\n          } else if (loop) {\n            const finalPage = page + offset;\n            finalTranslation = withSpring(withProcessTranslation(-finalPage * size), onFinished);\n          } else {\n            const finalPage = Math.min(maxPage - 1, Math.max(0, page + offset));\n            finalTranslation = withSpring(withProcessTranslation(-finalPage * size), onFinished);\n          }\n        }\n\n        if (!pagingEnabled && snapEnabled) {\n          // scroll to the nearest item\n          finalTranslation = withSpring(withProcessTranslation(-nextPage * size), onFinished);\n        }\n      }\n\n      translation.value = finalTranslation;\n\n      function withProcessTranslation(translation: number) {\n        if (!loop && !overscrollEnabled) {\n          const limit = getLimit();\n          const sign = Math.sign(translation);\n          return sign * Math.max(0, Math.min(limit, Math.abs(translation)));\n        }\n\n        return translation;\n      }\n    },\n    [\n      withSpring,\n      size,\n      maxPage,\n      loop,\n      snapEnabled,\n      translation,\n      pagingEnabled,\n      maxScrollDistancePerSwipe,\n      maxScrollDistancePerSwipeIsSet,\n    ]\n  );\n\n  const onFinish = React.useCallback(\n    (isFinished: boolean) => {\n      \"worklet\";\n      if (isFinished) {\n        touching.value = false;\n        onScrollEnd && runOnJS(onScrollEnd)();\n      }\n    },\n    [onScrollEnd, touching]\n  );\n\n  const activeDecay = React.useCallback(() => {\n    \"worklet\";\n    touching.value = true;\n    translation.value = withDecay({ velocity: scrollEndVelocity.value }, (isFinished) =>\n      onFinish(isFinished as boolean)\n    );\n  }, [onFinish, scrollEndVelocity, touching, translation]);\n\n  const resetBoundary = React.useCallback(() => {\n    \"worklet\";\n    if (touching.value) return;\n\n    if (translation.value > 0) {\n      if (scrollEndTranslation.value < 0) {\n        activeDecay();\n        return;\n      }\n      if (!loop) {\n        translation.value = withSpring(0);\n        return;\n      }\n    }\n\n    if (translation.value < -((maxPage - 1) * size)) {\n      if (scrollEndTranslation.value > 0) {\n        activeDecay();\n        return;\n      }\n      if (!loop) translation.value = withSpring(-((maxPage - 1) * size));\n    }\n  }, [touching, translation, maxPage, size, scrollEndTranslation, loop, activeDecay, withSpring]);\n\n  useAnimatedReaction(\n    () => translation.value,\n    () => {\n      if (!pagingEnabled) resetBoundary();\n    },\n    [pagingEnabled, resetBoundary]\n  );\n\n  function withProcessTranslation(translation: number) {\n    \"worklet\";\n\n    if (!loop && !overscrollEnabled) {\n      const limit = getLimit();\n      const sign = Math.sign(translation);\n      return sign * Math.max(0, Math.min(limit, Math.abs(translation)));\n    }\n\n    return translation;\n  }\n\n  const onGestureStart = useCallback(\n    (_: PanGestureHandlerEventPayload) => {\n      \"worklet\";\n\n      touching.value = true;\n      validStart.value = true;\n      onScrollStart && runOnJS(onScrollStart)();\n\n      max.value = (maxPage - 1) * size;\n      if (!loop && !overscrollEnabled) max.value = getLimit();\n\n      panOffset.value = translation.value;\n    },\n    [\n      max,\n      size,\n      maxPage,\n      loop,\n      touching,\n      panOffset,\n      validStart,\n      translation,\n      overscrollEnabled,\n      getLimit,\n      onScrollStart,\n    ]\n  );\n\n  const onGestureUpdate = useCallback(\n    (e: PanGestureHandlerEventPayload) => {\n      \"worklet\";\n\n      if (panOffset.value === undefined) {\n        // This may happen if `onGestureStart` is called as a part of the\n        // JS thread (instead of the UI thread / worklet). If so, when\n        // `onGestureStart` sets panOffset.value, the set will be asynchronous,\n        // and so it may not actually occur before `onGestureUpdate` is called.\n        //\n        // Keeping this value as `undefined` when it is not active protects us\n        // from the situation where we may use the previous value for panOffset\n        // instead; this would cause a visual flicker in the carousel.\n\n        // console.warn(\"onGestureUpdate: panOffset is undefined\");\n        return;\n      }\n\n      if (validStart.value) {\n        validStart.value = false;\n        cancelAnimation(translation);\n      }\n      touching.value = true;\n      const { translationX, translationY } = e;\n\n      let panTranslation = isHorizontal.value ? translationX : translationY;\n\n      if (fixedDirection === \"negative\") panTranslation = -Math.abs(panTranslation);\n      else if (fixedDirection === \"positive\") panTranslation = +Math.abs(panTranslation);\n\n      if (!loop) {\n        if (translation.value > 0 || translation.value < -max.value) {\n          const boundary = translation.value > 0 ? 0 : -max.value;\n          const fixed = boundary - panOffset.value;\n          const dynamic = panTranslation - fixed;\n          translation.value = boundary + dynamic * 0.5;\n          return;\n        }\n      }\n\n      const translationValue = panOffset.value + panTranslation;\n      translation.value = translationValue;\n    },\n    [\n      isHorizontal,\n      max,\n      panOffset,\n      loop,\n      overscrollEnabled,\n      fixedDirection,\n      translation,\n      validStart,\n      touching,\n    ]\n  );\n\n  const onGestureEnd = useCallback(\n    (e: GestureStateChangeEvent<PanGestureHandlerEventPayload>, _success: boolean) => {\n      \"worklet\";\n\n      if (panOffset.value === undefined) {\n        // console.warn(\"onGestureEnd: panOffset is undefined\");\n        return;\n      }\n\n      const { velocityX, velocityY, translationX, translationY } = e;\n      const scrollEndVelocityValue = isHorizontal.value ? velocityX : velocityY;\n      scrollEndVelocity.value = scrollEndVelocityValue; // may update async: see https://docs.swmansion.com/react-native-reanimated/docs/core/useSharedValue#remarks\n\n      let panTranslation = isHorizontal.value ? translationX : translationY;\n\n      if (fixedDirection === \"negative\") panTranslation = -Math.abs(panTranslation);\n      else if (fixedDirection === \"positive\") panTranslation = +Math.abs(panTranslation);\n\n      scrollEndTranslation.value = panTranslation; // may update async: see https://docs.swmansion.com/react-native-reanimated/docs/core/useSharedValue#remarks\n\n      const totalTranslation = scrollEndVelocityValue + panTranslation;\n\n      /**\n       * If the maximum scroll distance is set and the translation `exceeds the maximum scroll distance`,\n       * the carousel will keep the view at the current position.\n       */\n      if (\n        maxScrollDistancePerSwipeIsSet &&\n        Math.abs(totalTranslation) > maxScrollDistancePerSwipe\n      ) {\n        const nextPage =\n          Math.round(\n            (panOffset.value + maxScrollDistancePerSwipe * Math.sign(totalTranslation)) / size\n          ) * size;\n        translation.value = withSpring(withProcessTranslation(nextPage), onScrollEnd);\n      } else if (\n        /**\n         * If the minimum scroll distance is set and the translation `didn't exceeds the minimum scroll distance`,\n         * the carousel will keep the view at the current position.\n         */\n        minScrollDistancePerSwipeIsSet &&\n        Math.abs(totalTranslation) < minScrollDistancePerSwipe\n      ) {\n        const nextPage =\n          Math.round(\n            (panOffset.value + minScrollDistancePerSwipe * Math.sign(totalTranslation)) / size\n          ) * size;\n        translation.value = withSpring(withProcessTranslation(nextPage), onScrollEnd);\n      } else {\n        endWithSpring(panTranslation, scrollEndVelocityValue, onScrollEnd);\n      }\n\n      if (!loop) touching.value = false;\n\n      panOffset.value = undefined;\n    },\n    [\n      size,\n      loop,\n      touching,\n      panOffset,\n      translation,\n      isHorizontal,\n      scrollEndVelocity,\n      scrollEndTranslation,\n      fixedDirection,\n      maxScrollDistancePerSwipeIsSet,\n      maxScrollDistancePerSwipe,\n      maxScrollDistancePerSwipeIsSet,\n      minScrollDistancePerSwipe,\n      endWithSpring,\n      withSpring,\n      onScrollEnd,\n    ]\n  );\n\n  const gesture = usePanGestureProxy({\n    onConfigurePanGesture,\n    onGestureStart,\n    onGestureUpdate,\n    onGestureEnd,\n    options: { enabled },\n  });\n\n  const onLayout = React.useCallback(\n    (e: LayoutChangeEvent) => {\n      \"worklet\";\n      updateContainerSize({\n        width: e.nativeEvent.layout.width,\n        height: e.nativeEvent.layout.height,\n      });\n    },\n    [updateContainerSize]\n  );\n\n  return (\n    <GestureDetector gesture={gesture}>\n      <Animated.View\n        ref={containerRef}\n        testID={testID}\n        style={style}\n        onTouchStart={onTouchBegin}\n        onTouchEnd={onTouchEnd}\n        onLayout={onLayout}\n      >\n        {props.children}\n      </Animated.View>\n    </GestureDetector>\n  );\n};\n\nexport const ScrollViewGesture = IScrollViewGesture;\n"]}