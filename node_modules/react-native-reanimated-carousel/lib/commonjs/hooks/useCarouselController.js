"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useCarouselController = useCarouselController;

var _react = _interopRequireWildcard(require("react"));

var _reactNativeReanimated = require("react-native-reanimated");

var _constants = require("../constants");

var _store = require("../store");

var _computedWithAutoFillData = require("../utils/computed-with-auto-fill-data");

var _dealWithAnimation = require("../utils/deal-with-animation");

var _handleroffsetDirection = require("../utils/handleroffset-direction");

var _log = require("../utils/log");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function useCarouselController(options) {
  const {
    ref,
    size,
    loop,
    dataLength,
    handlerOffset,
    withAnimation,
    defaultIndex = 0,
    duration,
    autoFillData,
    fixedDirection
  } = options;
  const globalState = (0, _store.useGlobalState)();
  const {
    props: {
      overscrollEnabled
    },
    layout: {
      containerSize
    }
  } = globalState;

  const dataInfo = _react.default.useMemo(() => ({
    length: dataLength,
    disable: !dataLength,
    originalLength: dataLength
  }), [dataLength]);

  const index = (0, _reactNativeReanimated.useSharedValue)(defaultIndex); // The Index displayed to the user

  const sharedIndex = (0, _react.useRef)(defaultIndex);
  const sharedPreIndex = (0, _react.useRef)(defaultIndex);

  const currentFixedPage = _react.default.useCallback(() => {
    if (loop) return -Math.round(handlerOffset.value / size);
    const fixed = handlerOffset.value / size % dataInfo.length;
    return Math.round(handlerOffset.value <= 0 ? Math.abs(fixed) : Math.abs(fixed > 0 ? dataInfo.length - fixed : 0));
  }, [handlerOffset, dataInfo, size, loop]);

  function setSharedIndex(newSharedIndex) {
    sharedIndex.current = newSharedIndex;
  }

  (0, _reactNativeReanimated.useAnimatedReaction)(() => {
    const handlerOffsetValue = handlerOffset.value;
    const toInt = (0, _log.round)(handlerOffsetValue / size) % dataInfo.length;
    const isPositive = handlerOffsetValue <= 0;
    const i = isPositive ? Math.abs(toInt) : Math.abs(toInt > 0 ? dataInfo.length - toInt : 0);
    const newSharedIndexValue = (0, _computedWithAutoFillData.convertToSharedIndex)({
      loop,
      rawDataLength: dataInfo.originalLength,
      autoFillData: autoFillData,
      index: i
    });
    return {
      i,
      newSharedIndexValue
    };
  }, _ref => {
    let {
      i,
      newSharedIndexValue
    } = _ref;
    index.value = i;
    (0, _reactNativeReanimated.runOnJS)(setSharedIndex)(newSharedIndexValue);
  }, [sharedPreIndex, sharedIndex, size, dataInfo, index, loop, autoFillData, handlerOffset]);

  const getCurrentIndex = _react.default.useCallback(() => {
    const realIndex = (0, _computedWithAutoFillData.computedRealIndexWithAutoFillData)({
      index: index.value,
      dataLength: dataInfo.originalLength,
      loop,
      autoFillData: autoFillData
    });
    return realIndex;
  }, [index, autoFillData, dataInfo, loop]);

  const canSliding = _react.default.useCallback(() => {
    return !dataInfo.disable;
  }, [dataInfo]);

  const onScrollEnd = _react.default.useCallback(() => {
    var _options$onScrollEnd;

    (_options$onScrollEnd = options.onScrollEnd) === null || _options$onScrollEnd === void 0 ? void 0 : _options$onScrollEnd.call(options);
  }, [options]);

  const onScrollStart = _react.default.useCallback(() => {
    var _options$onScrollStar;

    (_options$onScrollStar = options.onScrollStart) === null || _options$onScrollStar === void 0 ? void 0 : _options$onScrollStar.call(options);
  }, [options]);

  const scrollWithTiming = _react.default.useCallback((toValue, onFinished) => {
    "worklet";

    const callback = isFinished => {
      "worklet";

      if (isFinished) {
        (0, _reactNativeReanimated.runOnJS)(onScrollEnd)();
        onFinished && (0, _reactNativeReanimated.runOnJS)(onFinished)();
      }
    };

    const defaultWithAnimation = {
      type: "timing",
      config: {
        duration,
        easing: _constants.Easing.easeOutQuart
      }
    };
    return (0, _dealWithAnimation.dealWithAnimation)(withAnimation !== null && withAnimation !== void 0 ? withAnimation : defaultWithAnimation)(toValue, callback);
  }, [duration, withAnimation, onScrollEnd]);

  const next = _react.default.useCallback(function () {
    "worklet";

    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      count = 1,
      animated = true,
      onFinished
    } = opts;
    if (!canSliding()) return;
    if (!loop && index.value >= dataInfo.length - 1) return;
    /* 
    [Overscroll Protection Logic]
    
    This section handles the overscroll protection when overscrollEnabled is false.
    It prevents scrolling beyond the visible content area.
     Example scenario:
    - Container width: 300px
    - Item width: 75px (4 items per view)
    - Total items: 6
    
    Initial state (index = 0):
    [0][1][2][3] | [4][5]
    visible      | remaining
     After 2 slides (index = 2):
    [0][1] | [2][3][4][5]
    hidden | visible
     The visibleContentWidth calculation:
    - At index 2, remaining items = 4 (items 2,3,4,5)
    - visibleContentWidth = 4 * 75px = 300px
    
    If we try to slide again:
    - New visibleContentWidth would be: 2 * 75px = 150px (only items 4,5 remain)
    - Since 150px < container width (300px), the slide is prevented
    
    This ensures we don't scroll beyond the last set of fully visible items,
    maintaining a clean UX without partial item visibility at the edges.
    */

    const visibleContentWidth = (dataInfo.length - index.value) * size;

    if (!overscrollEnabled && !(visibleContentWidth > containerSize.value.width)) {
      return;
    }

    onScrollStart === null || onScrollStart === void 0 ? void 0 : onScrollStart();
    const nextPage = currentFixedPage() + count;
    index.value = nextPage;

    if (animated) {
      handlerOffset.value = scrollWithTiming(-nextPage * size, onFinished);
    } else {
      handlerOffset.value = -nextPage * size;
      onFinished === null || onFinished === void 0 ? void 0 : onFinished();
    }
  }, [canSliding, loop, index, dataInfo, onScrollStart, handlerOffset, size, scrollWithTiming, currentFixedPage]);

  const prev = _react.default.useCallback(function () {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      count = 1,
      animated = true,
      onFinished
    } = opts;
    if (!canSliding()) return;
    if (!loop && index.value <= 0) return;
    onScrollStart === null || onScrollStart === void 0 ? void 0 : onScrollStart();
    const prevPage = currentFixedPage() - count;
    index.value = prevPage;

    if (animated) {
      handlerOffset.value = scrollWithTiming(-prevPage * size, onFinished);
    } else {
      handlerOffset.value = -prevPage * size;
      onFinished === null || onFinished === void 0 ? void 0 : onFinished();
    }
  }, [canSliding, loop, index, onScrollStart, handlerOffset, size, scrollWithTiming, currentFixedPage]);

  const to = _react.default.useCallback(opts => {
    const {
      i,
      animated = false,
      onFinished
    } = opts;
    if (i === index.value) return;
    if (!canSliding()) return;
    onScrollStart === null || onScrollStart === void 0 ? void 0 : onScrollStart(); // direction -> 1 | -1

    const direction = (0, _handleroffsetDirection.handlerOffsetDirection)(handlerOffset, fixedDirection); // target offset

    const offset = i * size * direction; // page width size * page count

    const totalSize = dataInfo.length * size;
    let isCloseToNextLoop = false;

    if (loop) {
      isCloseToNextLoop = Math.abs(handlerOffset.value % totalSize) / totalSize >= 0.5;
    }

    const finalOffset = (Math.floor(Math.abs(handlerOffset.value / totalSize)) + (isCloseToNextLoop ? 1 : 0)) * totalSize * direction + offset;

    if (animated) {
      index.value = i;
      handlerOffset.value = scrollWithTiming(finalOffset, onFinished);
    } else {
      handlerOffset.value = finalOffset;
      index.value = i;
      onFinished === null || onFinished === void 0 ? void 0 : onFinished();
    }
  }, [size, loop, index, fixedDirection, handlerOffset, dataInfo.length, canSliding, onScrollStart, scrollWithTiming]);

  const scrollTo = _react.default.useCallback(function () {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      index: i,
      count,
      animated = false,
      onFinished
    } = opts;

    if (typeof i === "number" && i > -1) {
      to({
        i,
        animated,
        onFinished
      });
      return;
    }

    if (!count) return;
    const n = Math.round(count);
    if (n < 0) prev({
      count: Math.abs(n),
      animated,
      onFinished
    });else next({
      count: n,
      animated,
      onFinished
    });
  }, [prev, next, to]);

  _react.default.useImperativeHandle(ref, () => ({
    next,
    prev,
    getCurrentIndex,
    scrollTo
  }), [getCurrentIndex, next, prev, scrollTo]);

  return {
    next,
    prev,
    scrollTo,
    getCurrentIndex,
    getSharedIndex: () => sharedIndex.current,
    index
  };
}
//# sourceMappingURL=useCarouselController.js.map