"use strict";

var _reactHooks = require("@testing-library/react-hooks");

var _useUpdateGestureConfig = require("./useUpdateGestureConfig");

describe("useUpdateGestureConfig", () => {
  const mockGesture = {
    enabled: jest.fn().mockReturnThis()
  };
  beforeEach(() => {
    jest.clearAllMocks();
  });
  it("should update gesture enabled state", () => {
    (0, _reactHooks.renderHook)(() => (0, _useUpdateGestureConfig.useUpdateGestureConfig)(mockGesture, {
      enabled: true
    }));
    expect(mockGesture.enabled).toHaveBeenCalledWith(true);
  });
  it("should handle undefined enabled state", () => {
    (0, _reactHooks.renderHook)(() => (0, _useUpdateGestureConfig.useUpdateGestureConfig)(mockGesture, {}));
    expect(mockGesture.enabled).not.toHaveBeenCalled();
  });
  it("should update when enabled state changes", () => {
    const {
      rerender
    } = (0, _reactHooks.renderHook)(props => (0, _useUpdateGestureConfig.useUpdateGestureConfig)(mockGesture, props), {
      initialProps: {
        enabled: true
      }
    });
    expect(mockGesture.enabled).toHaveBeenCalledWith(true);
    rerender({
      enabled: false
    });
    expect(mockGesture.enabled).toHaveBeenCalledWith(false);
  });
  it("should not update when enabled state remains the same", () => {
    const {
      rerender
    } = (0, _reactHooks.renderHook)(props => (0, _useUpdateGestureConfig.useUpdateGestureConfig)(mockGesture, props), {
      initialProps: {
        enabled: true
      }
    });
    mockGesture.enabled.mockClear();
    rerender({
      enabled: true
    });
    expect(mockGesture.enabled).not.toHaveBeenCalled();
  });
  it("should handle gesture object changes", () => {
    const newMockGesture = {
      enabled: jest.fn().mockReturnThis()
    };
    const {
      rerender
    } = (0, _reactHooks.renderHook)(_ref => {
      let {
        gesture,
        config
      } = _ref;
      return (0, _useUpdateGestureConfig.useUpdateGestureConfig)(gesture, config);
    }, {
      initialProps: {
        gesture: mockGesture,
        config: {
          enabled: true
        }
      }
    });
    expect(mockGesture.enabled).toHaveBeenCalledWith(true);
    rerender({
      gesture: newMockGesture,
      config: {
        enabled: true
      }
    });
    expect(newMockGesture.enabled).toHaveBeenCalledWith(true);
  });
  it("should cleanup properly on unmount", () => {
    const {
      unmount
    } = (0, _reactHooks.renderHook)(() => (0, _useUpdateGestureConfig.useUpdateGestureConfig)(mockGesture, {
      enabled: true
    }));
    mockGesture.enabled.mockClear();
    unmount();
    expect(mockGesture.enabled).not.toHaveBeenCalled();
  });
});
//# sourceMappingURL=useUpdateGestureConfig.test.js.map