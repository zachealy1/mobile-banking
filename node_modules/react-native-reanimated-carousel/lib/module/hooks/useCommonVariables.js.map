{"version":3,"sources":["useCommonVariables.ts"],"names":["useAnimatedReaction","useSharedValue","computeOffsetIfDataChanged","computeOffsetIfSizeChanged","handlerOffsetDirection","useCommonVariables","props","vertical","height","width","dataLength","defaultIndex","defaultScrollOffsetValue","loop","size","defaultHandlerOffsetValue","Math","abs","_handlerOffset","handlerOffset","prevDataLength","prevSize","previousLength","value","currentLength","isLengthChanged","shouldComputed","direction","previousSize","isSizeChanged","validLength"],"mappings":"AACA,SAASA,mBAAT,EAA8BC,cAA9B,QAAoD,yBAApD;AAIA,SAASC,0BAAT,QAA2C,yCAA3C;AACA,SAASC,0BAAT,QAA2C,yCAA3C;AACA,SAASC,sBAAT,QAAuC,kCAAvC;AAQA,OAAO,SAASC,kBAAT,CAA4BC,KAA5B,EAAoF;AACzF,QAAM;AAAEC,IAAAA,QAAF;AAAYC,IAAAA,MAAZ;AAAoBC,IAAAA,KAApB;AAA2BC,IAAAA,UAA3B;AAAuCC,IAAAA,YAAvC;AAAqDC,IAAAA,wBAArD;AAA+EC,IAAAA;AAA/E,MACJP,KADF;AAEA,QAAMQ,IAAI,GAAGP,QAAQ,GAAGC,MAAH,GAAYC,KAAjC;AACA,QAAMM,yBAAyB,GAAG,CAACC,IAAI,CAACC,GAAL,CAASN,YAAY,GAAGG,IAAxB,CAAnC;;AACA,QAAMI,cAAc,GAAGjB,cAAc,CAASc,yBAAT,CAArC;;AACA,QAAMI,aAAa,GAAGP,wBAAH,aAAGA,wBAAH,cAAGA,wBAAH,GAA+BM,cAAlD;AACA,QAAME,cAAc,GAAGnB,cAAc,CAACS,UAAD,CAArC;AACA,QAAMW,QAAQ,GAAGpB,cAAc,CAACa,IAAD,CAA/B;AAEA;AACF;AACA;;AACEd,EAAAA,mBAAmB,CACjB,MAAM;AACJ,UAAMsB,cAAc,GAAGF,cAAc,CAACG,KAAtC;AACA,UAAMC,aAAa,GAAGd,UAAtB;AACA,UAAMe,eAAe,GAAGH,cAAc,KAAKE,aAA3C;AACA,UAAME,cAAc,GAAGD,eAAe,IAAIZ,IAA1C;AAEA,QAAIa,cAAJ,EAAoBN,cAAc,CAACG,KAAf,GAAuBb,UAAvB;AAEpB,WAAO;AACLgB,MAAAA,cADK;AAELJ,MAAAA,cAFK;AAGLE,MAAAA;AAHK,KAAP;AAKD,GAdgB,EAejB,QAAuD;AAAA,QAAtD;AAAEE,MAAAA,cAAF;AAAkBJ,MAAAA,cAAlB;AAAkCE,MAAAA;AAAlC,KAAsD;;AACrD,QAAIE,cAAJ,EAAoB;AAClB;AACA,YAAMC,SAAS,GAAGvB,sBAAsB,CAACe,aAAD,CAAxC;AAEAA,MAAAA,aAAa,CAACI,KAAd,GAAsBrB,0BAA0B,CAAC;AAC/CyB,QAAAA,SAD+C;AAE/CL,QAAAA,cAF+C;AAG/CE,QAAAA,aAH+C;AAI/CV,QAAAA,IAJ+C;AAK/CK,QAAAA,aAAa,EAAEA,aAAa,CAACI;AALkB,OAAD,CAAhD;AAOD;AACF,GA5BgB,EA6BjB,CAACb,UAAD,EAAaG,IAAb,CA7BiB,CAAnB;AAgCA;AACF;AACA;;AACEb,EAAAA,mBAAmB,CACjB,MAAM;AACJ,UAAM4B,YAAY,GAAGP,QAAQ,CAACE,KAA9B;AACA,UAAMM,aAAa,GAAGD,YAAY,KAAKd,IAAvC;AACA,UAAMY,cAAc,GAAGG,aAAvB;AAEA,QAAIH,cAAJ,EAAoBL,QAAQ,CAACE,KAAT,GAAiBT,IAAjB;AAEpB,WAAO;AACLY,MAAAA,cADK;AAELE,MAAAA,YAFK;AAGLd,MAAAA;AAHK,KAAP;AAKD,GAbgB,EAcjB,SAA4C;AAAA,QAA3C;AAAEY,MAAAA,cAAF;AAAkBE,MAAAA,YAAlB;AAAgCd,MAAAA;AAAhC,KAA2C;;AAC1C,QAAIY,cAAJ,EAAoB;AAClBP,MAAAA,aAAa,CAACI,KAAd,GAAsBpB,0BAA0B,CAAC;AAC/CgB,QAAAA,aAAa,EAAEA,aAAa,CAACI,KADkB;AAE/CF,QAAAA,QAAQ,EAAEO,YAFqC;AAG/Cd,QAAAA;AAH+C,OAAD,CAAhD;AAKD;AACF,GAtBgB,EAuBjB,CAACA,IAAD,CAvBiB,CAAnB;AA0BA,SAAO;AACLA,IAAAA,IADK;AAELgB,IAAAA,WAAW,EAAEpB,UAAU,GAAG,CAFrB;AAGLS,IAAAA;AAHK,GAAP;AAKD","sourcesContent":["import type Animated from \"react-native-reanimated\";\nimport { useAnimatedReaction, useSharedValue } from \"react-native-reanimated\";\n\nimport type { TInitializeCarouselProps } from \"./useInitProps\";\n\nimport { computeOffsetIfDataChanged } from \"../utils/compute-offset-if-data-changed\";\nimport { computeOffsetIfSizeChanged } from \"../utils/compute-offset-if-size-changed\";\nimport { handlerOffsetDirection } from \"../utils/handleroffset-direction\";\n\ninterface ICommonVariables {\n  size: number;\n  validLength: number;\n  handlerOffset: Animated.SharedValue<number>;\n}\n\nexport function useCommonVariables(props: TInitializeCarouselProps<any>): ICommonVariables {\n  const { vertical, height, width, dataLength, defaultIndex, defaultScrollOffsetValue, loop } =\n    props;\n  const size = vertical ? height : width;\n  const defaultHandlerOffsetValue = -Math.abs(defaultIndex * size);\n  const _handlerOffset = useSharedValue<number>(defaultHandlerOffsetValue);\n  const handlerOffset = defaultScrollOffsetValue ?? _handlerOffset;\n  const prevDataLength = useSharedValue(dataLength);\n  const prevSize = useSharedValue(size);\n\n  /**\n   * When data changes, we need to compute new index for handlerOffset\n   */\n  useAnimatedReaction(\n    () => {\n      const previousLength = prevDataLength.value;\n      const currentLength = dataLength;\n      const isLengthChanged = previousLength !== currentLength;\n      const shouldComputed = isLengthChanged && loop;\n\n      if (shouldComputed) prevDataLength.value = dataLength;\n\n      return {\n        shouldComputed,\n        previousLength,\n        currentLength,\n      };\n    },\n    ({ shouldComputed, previousLength, currentLength }) => {\n      if (shouldComputed) {\n        // direction -> 1 | -1\n        const direction = handlerOffsetDirection(handlerOffset);\n\n        handlerOffset.value = computeOffsetIfDataChanged({\n          direction,\n          previousLength,\n          currentLength,\n          size,\n          handlerOffset: handlerOffset.value,\n        });\n      }\n    },\n    [dataLength, loop]\n  );\n\n  /**\n   * When size changes, we need to compute new index for handlerOffset\n   */\n  useAnimatedReaction(\n    () => {\n      const previousSize = prevSize.value;\n      const isSizeChanged = previousSize !== size;\n      const shouldComputed = isSizeChanged;\n\n      if (shouldComputed) prevSize.value = size;\n\n      return {\n        shouldComputed,\n        previousSize,\n        size,\n      };\n    },\n    ({ shouldComputed, previousSize, size }) => {\n      if (shouldComputed) {\n        handlerOffset.value = computeOffsetIfSizeChanged({\n          handlerOffset: handlerOffset.value,\n          prevSize: previousSize,\n          size,\n        });\n      }\n    },\n    [size]\n  );\n\n  return {\n    size,\n    validLength: dataLength - 1,\n    handlerOffset,\n  };\n}\n"]}