{"version":3,"sources":["useOffsetX.ts"],"names":["Extrapolation","interpolate","useDerivedValue","useOffsetX","opts","visibleRanges","handlerOffset","index","size","loop","dataLength","type","viewCount","_viewCount","ITEM_LENGTH","VALID_LENGTH","TOTAL_WIDTH","HALF_WIDTH","Math","round","positiveCount","startPos","MAX","MIN","x","negativeRange","positiveRange","value","inputRange","Number","MIN_VALUE","outputRange","CLAMP","MAX_SAFE_INTEGER"],"mappings":"AACA,SAASA,aAAT,EAAwBC,WAAxB,EAAqCC,eAArC,QAA4D,yBAA5D;AAcA,OAAO,MAAMC,UAAU,GAAG,CAACC,IAAD,EAAcC,aAAd,KAAgD;AACxE,QAAM;AACJC,IAAAA,aADI;AAEJC,IAAAA,KAFI;AAGJC,IAAAA,IAHI;AAIJC,IAAAA,IAJI;AAKJC,IAAAA,UALI;AAMJC,IAAAA,IAAI,GAAG,UANH;AAOJC,IAAAA,SAAS,EAAEC;AAPP,MAQFT,IARJ;AAUA,QAAMU,WAAW,GAAGJ,UAApB;AACA,QAAMK,YAAY,GAAGD,WAAW,GAAG,CAAnC;AACA,QAAME,WAAW,GAAGR,IAAI,GAAGM,WAA3B;AACA,QAAMG,UAAU,GAAG,MAAMT,IAAzB;AAEA,QAAMI,SAAS,GAAGC,UAAH,aAAGA,UAAH,cAAGA,UAAH,GAAiBK,IAAI,CAACC,KAAL,CAAW,CAACL,WAAW,GAAG,CAAf,IAAoB,CAA/B,CAAhC;AACA,QAAMM,aAAa,GAAGT,IAAI,KAAK,UAAT,GAAsBC,SAAtB,GAAkCG,YAAY,GAAGH,SAAvE;AAEA,MAAIS,QAAQ,GAAGb,IAAI,GAAGD,KAAtB;AACA,MAAIA,KAAK,GAAGa,aAAZ,EAA2BC,QAAQ,GAAG,CAACd,KAAK,GAAGO,WAAT,IAAwBN,IAAnC;AAE3B,QAAMc,GAAG,GAAGF,aAAa,GAAGZ,IAA5B;AACA,QAAMe,GAAG,GAAG,EAAE,CAACR,YAAY,GAAGK,aAAhB,IAAiCZ,IAAnC,CAAZ;AAEA,QAAMgB,CAAC,GAAGtB,eAAe,CAAC,MAAM;AAC9B,UAAM;AAAEuB,MAAAA,aAAF;AAAiBC,MAAAA;AAAjB,QAAmCrB,aAAa,CAACsB,KAAvD;;AAEA,QACGpB,KAAK,IAAIkB,aAAa,CAAC,CAAD,CAAtB,IAA6BlB,KAAK,IAAIkB,aAAa,CAAC,CAAD,CAApD,IACClB,KAAK,IAAImB,aAAa,CAAC,CAAD,CAAtB,IAA6BnB,KAAK,IAAImB,aAAa,CAAC,CAAD,CAFtD,EAGE;AACA,UAAIjB,IAAJ,EAAU;AACR,cAAMmB,UAAU,GAAG,CACjB,CAACZ,WADgB,EAEjBO,GAAG,GAAGN,UAAN,GAAmBI,QAAnB,GAA8BQ,MAAM,CAACC,SAFpB,EAGjBP,GAAG,GAAGN,UAAN,GAAmBI,QAHF,EAIjB,CAJiB,EAKjBC,GAAG,GAAGL,UAAN,GAAmBI,QALF,EAMjBC,GAAG,GAAGL,UAAN,GAAmBI,QAAnB,GAA8BQ,MAAM,CAACC,SANpB,EAOjBd,WAPiB,CAAnB;AAUA,cAAMe,WAAW,GAAG,CAClBV,QADkB,EAElBC,GAAG,GAAGL,UAAN,GAAmBY,MAAM,CAACC,SAFR,EAGlBP,GAAG,GAAGN,UAHY,EAIlBI,QAJkB,EAKlBC,GAAG,GAAGL,UALY,EAMlBM,GAAG,GAAGN,UAAN,GAAmBY,MAAM,CAACC,SANR,EAOlBT,QAPkB,CAApB;AAUA,eAAOpB,WAAW,CAACK,aAAa,CAACqB,KAAf,EAAsBC,UAAtB,EAAkCG,WAAlC,EAA+C/B,aAAa,CAACgC,KAA7D,CAAlB;AACD;;AAED,aAAO1B,aAAa,CAACqB,KAAd,GAAsBnB,IAAI,GAAGD,KAApC;AACD;;AAED,WAAOsB,MAAM,CAACI,gBAAd;AACD,GAnCwB,EAmCtB,CAACxB,IAAD,EAAOC,UAAP,EAAmBE,SAAnB,EAA8BD,IAA9B,EAAoCH,IAApC,EAA0CH,aAA1C,CAnCsB,CAAzB;AAqCA,SAAOmB,CAAP;AACD,CA/DM","sourcesContent":["import type Animated from \"react-native-reanimated\";\nimport { Extrapolation, interpolate, useDerivedValue } from \"react-native-reanimated\";\n\nimport type { IVisibleRanges } from \"./useVisibleRanges\";\n\nexport interface IOpts {\n  index: number;\n  size: number;\n  handlerOffset: Animated.SharedValue<number>;\n  dataLength: number;\n  type?: \"positive\" | \"negative\";\n  viewCount?: number;\n  loop?: boolean;\n}\n\nexport const useOffsetX = (opts: IOpts, visibleRanges: IVisibleRanges) => {\n  const {\n    handlerOffset,\n    index,\n    size,\n    loop,\n    dataLength,\n    type = \"positive\",\n    viewCount: _viewCount,\n  } = opts;\n\n  const ITEM_LENGTH = dataLength;\n  const VALID_LENGTH = ITEM_LENGTH - 1;\n  const TOTAL_WIDTH = size * ITEM_LENGTH;\n  const HALF_WIDTH = 0.5 * size;\n\n  const viewCount = _viewCount ?? Math.round((ITEM_LENGTH - 1) / 2);\n  const positiveCount = type === \"positive\" ? viewCount : VALID_LENGTH - viewCount;\n\n  let startPos = size * index;\n  if (index > positiveCount) startPos = (index - ITEM_LENGTH) * size;\n\n  const MAX = positiveCount * size;\n  const MIN = -((VALID_LENGTH - positiveCount) * size);\n\n  const x = useDerivedValue(() => {\n    const { negativeRange, positiveRange } = visibleRanges.value;\n\n    if (\n      (index >= negativeRange[0] && index <= negativeRange[1]) ||\n      (index >= positiveRange[0] && index <= positiveRange[1])\n    ) {\n      if (loop) {\n        const inputRange = [\n          -TOTAL_WIDTH,\n          MIN - HALF_WIDTH - startPos - Number.MIN_VALUE,\n          MIN - HALF_WIDTH - startPos,\n          0,\n          MAX + HALF_WIDTH - startPos,\n          MAX + HALF_WIDTH - startPos + Number.MIN_VALUE,\n          TOTAL_WIDTH,\n        ];\n\n        const outputRange = [\n          startPos,\n          MAX + HALF_WIDTH - Number.MIN_VALUE,\n          MIN - HALF_WIDTH,\n          startPos,\n          MAX + HALF_WIDTH,\n          MIN - HALF_WIDTH + Number.MIN_VALUE,\n          startPos,\n        ];\n\n        return interpolate(handlerOffset.value, inputRange, outputRange, Extrapolation.CLAMP);\n      }\n\n      return handlerOffset.value + size * index;\n    }\n\n    return Number.MAX_SAFE_INTEGER;\n  }, [loop, dataLength, viewCount, type, size, visibleRanges]);\n\n  return x;\n};\n"]}