{"version":3,"sources":["useVisibleRanges.tsx"],"names":["useRef","useDerivedValue","useVisibleRanges","options","total","viewSize","translation","windowSize","_windowSize","loop","cachedRanges","ranges","positiveCount","Math","round","negativeCount","currentIndex","value","newRanges","negativeRange","positiveRange","isArraysEqual","current","a","b","length","every","index"],"mappings":"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","sourcesContent":["import { useRef } from \"react\";\nimport type Animated from \"react-native-reanimated\";\nimport { useDerivedValue } from \"react-native-reanimated\";\n\ntype Range = [number, number];\n\nexport interface VisibleRanges {\n  negativeRange: Range;\n  positiveRange: Range;\n}\n\nexport type IVisibleRanges = Animated.SharedValue<VisibleRanges>;\n\nexport function useVisibleRanges(options: {\n  total: number;\n  viewSize: number;\n  windowSize?: number;\n  translation: Animated.SharedValue<number>;\n  loop?: boolean;\n}): IVisibleRanges {\n  const { total = 0, viewSize, translation, windowSize: _windowSize, loop } = options;\n\n  const windowSize = _windowSize ?? total;\n  const cachedRanges = useRef<VisibleRanges>(null!);\n\n  const ranges = useDerivedValue(() => {\n    const positiveCount = Math.round(windowSize / 2);\n    const negativeCount = windowSize - positiveCount;\n\n    let currentIndex = Math.round(-translation.value / viewSize);\n    currentIndex = currentIndex < 0 ? (currentIndex % total) + total : currentIndex;\n\n    let newRanges: VisibleRanges;\n\n    if (!loop) {\n      // Adjusting negative range if the carousel is not loopable.\n      // So, It will be only displayed the positive items.\n      newRanges = {\n        negativeRange: [0 + currentIndex - (windowSize - 1), 0 + currentIndex],\n        positiveRange: [0 + currentIndex, currentIndex + (windowSize - 1)],\n      };\n    } else {\n      const negativeRange: Range = [\n        (currentIndex - negativeCount + total) % total,\n        (currentIndex - 1 + total) % total,\n      ];\n\n      const positiveRange: Range = [\n        (currentIndex + total) % total,\n        (currentIndex + positiveCount + total) % total,\n      ];\n\n      if (negativeRange[0] < total && negativeRange[0] > negativeRange[1]) {\n        negativeRange[1] = total - 1;\n        positiveRange[0] = 0;\n      }\n      if (positiveRange[0] > positiveRange[1]) {\n        negativeRange[1] = total - 1;\n        positiveRange[0] = 0;\n      }\n\n      // console.log({ negativeRange, positiveRange ,total,windowSize,a:total <= _windowSize})\n      newRanges = { negativeRange, positiveRange };\n    }\n\n    if (\n      isArraysEqual(cachedRanges.current?.negativeRange ?? [], newRanges.negativeRange) &&\n      isArraysEqual(cachedRanges.current?.positiveRange ?? [], newRanges.positiveRange)\n    )\n      return cachedRanges.current;\n\n    cachedRanges.current = newRanges;\n    return cachedRanges.current;\n  }, [loop, total, windowSize, translation]);\n\n  return ranges;\n}\n\nfunction isArraysEqual(a: number[], b: number[]): boolean {\n  \"worklet\";\n  if (a.length !== b.length) return false;\n\n  return a.every((value, index) => value === b[index]);\n}\n"]}